


# sk - l73 -------------------------------------------------------------------------------------------

# class Solution:
#     def setZeroes(self, matrix: List[List[int]]) -> None:
#         """
#         Do not return anything, modify matrix in-place instead.
#         """
#         rows = len(matrix)
#         columns = len(matrix[0])

#         row_first_flag = None
#         column_first_flag = None

#         for column in range(columns):
#            if matrix[0][column] == 0:
#               row_first_flag = True
        
#         for row in range(rows):
#              if matrix[row][0] == 0:
#                 column_first_flag = True
        
#         for row in range(rows):
#             for column in range(columns):
#                 if matrix[row][column] == 0:
#                     matrix[0][column] = 0
#                     matrix[row][0] = 0
        
#         for row in range(1,rows):
#             for column in range(1,columns):
#                 if matrix[0][column] == 0 or matrix[row][0] == 0:
#                     matrix[row][column] = 0
        
#         if row_first_flag:
#             for column in range(columns):
#                 matrix[0][column] = 0
        
#         if column_first_flag:
#             for row in range(rows):
#                 matrix[row][0] = 0

class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """

        rows = len(matrix)
        columns = len(matrix[0])

        first_row_zero = False
        first_column_zero = False

        for column in range(columns):
            if matrix[0][column] == 0:
                first_row_zero = True
        
        for row in range(rows):
            if matrix[row][0] == 0:
                first_column_zero = True
        
        for row in range(rows):
            for column in range(columns):
                if matrix[row][column] == 0:
                    matrix[0][column] = 0
                    matrix[row][0] = 0
        
        for row in range(1,rows):
            for column in range(1,columns):
                if matrix[0][column] == 0 or matrix[row][0] == 0:
                    matrix[row][column] = 0
        
        if first_row_zero:
            for column in range(columns):
                matrix[0][column] = 0
        
        if first_column_zero:
            for row in range(rows):
                matrix[row][0] = 0

                

# sk - L3 -----------------------------------------------------------------------

# class Solution:
#     def lengthOfLongestSubstring(self, s: str) -> int:
#         max_length = 1
#         left = 0
#         right = 0
#         string_map = {}
#         string_map[s[right]] = right
#         length = 1
#         while right <= len(s)-2:
#             right = right + 1
#             if s[right] in string_map:
#                 left = string_map[s[right]] + 1
#                 length = 1
#             else:
#                 string_map[s[right]] = right
#                 length = length + 1
#             if length > max_length:
#                 max_length = length

#         return max_length            

# class Solution:
#     def lengthOfLongestSubstring(self, s: str) -> int:
#         character_dict = {}
#         right = 0
#         left = 0
#         max_length = 0
#         for i in range(len(s)):

#             if s[right] not in character_dict:
#                 character_dict[s[right]] = right
            
#             else:
#                 left = character_dict[s[right]] + 1
#                 character_dict[s[right]] = right

            
#             length = (right - left) + 1
#             if length > max_length:
#                 max_length = length
            
#             right = right + 1

#         return max_length 

# class Solution:
#     def lengthOfLongestSubstring(self, s: str) -> int:

#         if len(s) == 1:
#             return 1
#         if len(s) == "":
#             return 0

#         left = 0
#         right = 1
#         length = 0
#         max_length = 0
#         sub_array = [s[0]]

#         for i in range(len(s)-1):
#             if sub_array and s[right] in sub_array:
#                 left = right
#                 length = len(sub_array)
#                 sub_array = [s[left]]
#             elif  s[left] == s[right]:
#                 left = left + 1
#                 length = len(sub_array)
#                 sub_array = sub_array[left:]
            
#             else:
#                 length = len(sub_array)
#                 sub_array.append(s[right])
                

#             if length > max_length:
#                 max_length = length
#             right = right + 1
        
#         return max_length
            

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        if len(s) == 1:
            return 1
        if len(s) == "":
            return 0   

        left = 0
        right = 1
        sub_array = [s[0]]
        max_length = 0

        while left <= right and right < len(s):
            if s[left] == s[right]:
                left = left + 1
                sub_array[left:]
            elif s[right] in sub_array:
                left = right
                sub_array = [s[left]]
            else:
                sub_array.append(s[right])
            
            length = len(sub_array)
            if length > max_length:
                max_length = length
            right = right + 1
        
        return max_length



        





# sk - L53 -----------------------------------------------------------------------


# class Solution:
#     def maxSubArray(self, nums: List[int]) -> int:
#         current_sum = nums[0]
#         max_sum = nums[0]
#         for i in range(1,len(nums)):
#             if max(nums[i], current_sum+nums[i]) == nums[i]:
#                 current_sum = nums[i]
#             else:
#                 current_sum = current_sum + nums[i]
                
#             if current_sum > max_sum:
#                 max_sum = current_sum
#         return max_sum

# class Solution:
#     def maxSubArray(self, nums: List[int]) -> int:
#         max_sum = nums[0]
#         current_sum = nums[0]
#         for i in range(1, len(nums)):
#             if max(nums[i], nums[i] + current_sum) == nums[i]:
#                 current_sum = nums[i]
#             else:
#                 current_sum = current_sum + nums[i]
            
#             if current_sum > max_sum:
#                 max_sum = current_sum
        
#         return max_sum
               
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:

        running_sum = 0
        result = []
        max_sum = 0

        for i in range(len(nums)):

            if max(nums[i], nums[i]+running_sum) == nums[i]:
                running_sum = nums[i]
                if running_sum > max_sum:
                    max_sum = running_sum
            
            else:
                running_sum = running_sum + nums[i]
                if running_sum > max_sum:
                    max_sum = running_sum
        
        return max_sum
        
            


# sk - L102 -----------------------------------------------------------------------

# # Definition for a binary tree node.
# # class TreeNode:
# #     def __init__(self, val=0, left=None, right=None):
# #         self.val = val
# #         self.left = left
# #         self.right = right
# class Solution:
#     from collections import deque

#     def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:

#         result = []

#         if root:
#             queue = deque([root])
        
#         if not root:
#             return []


        
#         while queue:

#             level_size = len(queue)
#             level = []

#             for i in range(level_size):
            
#                 node = queue.popleft()
#                 level.append(node.val)

#                 if node.left:
#                     queue.append(node.left)
#                 if node.right:
#                     queue.append(node.right)
            
#             result.append(level)
#         return result
        
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    from collections import deque
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:

            if root:
                queue = deque([root])

            if not root:
                return []

            results = []
            while queue:
                level_size = len(queue)
                level = []
                for i in range(level_size):
                    node = queue.popleft()
                    level.append(node.val)

                    if node.left:
                        queue.append(node.left)
                    if node.right:
                        queue.append(node.right)
                results.append(level)
            return results


            




        

# sk - L380 -----------------------------------------------------------------------

# class RandomizedSet:

#     def __init__(self):

#         self.list = []
#         self.index_mapping = {}
        

#     def insert(self, val: int) -> bool:

#         if val in self.list:
#             return False
        
#         self.list.append(val)
#         self.index_mapping[val] = len(self.list)-1
#         return True

        
#     def remove(self, val: int) -> bool:

#         if val not in self.list:
#             return False
        
#         index = self.index_mapping[val]
#         last_element = self.list[-1]
#         self.list[index] = last_element
#         self.index_mapping[last_element] = index

#         self.list.pop()
#         del self.index_mapping[val]
#         return True

#     def getRandom(self) -> int:

#         import random

#         return random.choice(self.list)
        
        
class RandomizedSet:

    def __init__(self):

        self.stack = []
        self.index_mapping = {}
        

    def insert(self, val: int) -> bool:

        if val in self.index_mapping:
            return False
        else:
            self.stack.append(val)
            self.index_mapping[val] = len(self.stack) -1
            return True
        
    def remove(self, val: int) -> bool:

        if val not in self.index_mapping:
            return False
        
        else:
            self.stack.pop(self.index_mapping[val])
            del self.index_mapping[val]
            return True

    def getRandom(self) -> int:
        import random
        return (random.choice(self.stack))

  

# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()

# sk - L200 -----------------------------------------------------------------------

# class Solution:
#     def numIslands(self, grid: List[List[str]]) -> int:

#         if not grid:
#             return 0


#         def dfs(i,j):

#             if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
#                 return
            
#             grid[i][j] = '0'

#             dfs(i-1, j)
#             dfs(i+1, j)
#             dfs(i,j-1)
#             dfs(i,j+1)


#         island_count = 0
#         for i in range(len(grid)):
#             for j in range(len(grid[0])):

#                 if grid[i][j] == '1':
#                     island_count = island_count + 1
#                     dfs(i,j)
        
#         return island_count




class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:

        

        num_islands = 0
        if not grid:
             return 0

        def dfs(i,j):

            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == '0':
               return 
            
            grid[i][j] = '0'

            dfs(i-1, j) 
            dfs(i+1, j) 
            dfs(i, j-1) 
            dfs(i, j+1) 


        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    num_islands = num_islands + 1
                    dfs(i,j)
        return num_islands



        



# sk - L146 -----------------------------------------------------------------------




class Node :

    def __init__(self, key, value):

        self.key = key
        self.value = value
        self.next = None
        self.prev = None


class LRUCache:

    def __init__(self, capacity: int):

        self.capacity = capacity
        self.cache = {}
        self.head = Node(0,0)
        self.tail = Node(0,0)
        self.head.next = self.tail
        self.tail.prev = self.head
        
    def move_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def add_node(self, node):

        node.next = self.head.next
        node.prev = self.head

        self.head.next = node
        node.next.prev = node 

    def remove_tail_node(self):

        last_node = self.tail.prev

        last_node.prev.next = self.tail
        self.tail.prev = last_node.prev

        return last_node
            

    def get(self, key: int) -> int:

        if key in self.cache:
            node = self.cache[key]
            self.move_node(node)
            return node.value

        return -1
        
    def put(self, key: int, value: int) -> None:

        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self.move_node(node)
        
        else:

            node = Node(key,value)

            self.cache[key] = node
            self.add_node(node)

            if len(self.cache) > self.capacity:
                tail_node = self.remove_tail_node() 
                del self.cache[tail_node.key]
        


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)


# sk - L347 -----------------------------------------------------------------------


# class Solution:
#     def topKFrequent(self, nums: List[int], k: int) -> List[int]:
#         result_dict = {}
#         heap = []
#         for i in nums:
#             if i in result_dict:
#                 result_dict[i] = result_dict[i] + 1
#             else:
#                 result_dict[i] = 1
        
        
#         for key, value in result_dict.items():
#             heapq.heappush(heap, (-value, key) )
        
#         res = []
#         while len(res) < k:
#             res.append(heapq.heappop(heap)[1])
        
#         return res


class Solution:
    import heapq
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        frequency_dict = {}
        for i in nums:
            if i in frequency_dict:
                frequency_dict[i] = frequency_dict[i] + 1
            else: 
                frequency_dict[i] = 1
        
        heap = []

        for key, value in frequency_dict.items():
            heapq.heappush(heap, (-value, key) )
        
        result = []

        while len(result) < k:
           result.append(heapq.heappop(heap)[1])
        
        return result
            
            



# sk - L23 -----------------------------------------------------------------------

# #Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next


# class Solution:
#     import heapq
#     def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:

#         heap = []
        
#         for i, head in enumerate(lists):
#             if head:  
#                 heapq.heappush(heap, (head.val, i, head))  
        
#         Dummy = ListNode()
#         current = Dummy


#         while heap:

#             value, index, node = heapq.heappop(heap)

#             current.next = node
#             current = current.next

#             if node.next:
#                 heapq.heappush(heap, (node.next.val, index, node.next))

#         return Dummy.next

        
#Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    import heapq
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:


        heap = []
        Dummy = ListNode()
        current = Dummy

        for i,head in enumerate(lists):
            if head:
                heapq.heappush(heap, (head.val, i, head))  
            
        while heap:
            value, index, node = heapq.heappop(heap)
            current.next = node
        

            if node.next:
                heapq.heappush(heap, (node.next.val, index, node.next))
            current =  current.next
        
        return Dummy.next

